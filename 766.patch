diff --git a/.gitignore b/.gitignore
index d450665..0611f43 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,6 +4,7 @@
 *.oo
 *.oo2
 *.pyc
+*.orig
 
 # Libraries
 *.lib
diff --git a/include/MySQL_Thread.h b/include/MySQL_Thread.h
index 0d72ecb..ac74f5b 100644
--- a/include/MySQL_Thread.h
+++ b/include/MySQL_Thread.h
@@ -302,6 +302,8 @@ class MySQL_Threads_Handler
 		int max_transaction_time;
 		int threshold_query_length;
 		int threshold_resultset_size;
+		int query_digests_max_digest_length;
+		int query_digests_max_query_length;
 		int wait_timeout;
 		int max_connections;
 		int default_max_latency_ms;
diff --git a/include/c_tokenizer.h b/include/c_tokenizer.h
index 0d6a017..f08246c 100644
--- a/include/c_tokenizer.h
+++ b/include/c_tokenizer.h
@@ -10,10 +10,6 @@
 #define FIRST_COMMENT_MAX_LENGTH  1024
 #endif /* FIRST_COMMENT_MAX_LENGTH */
 
-#ifndef QUERY_DIGEST_MAX_LENGTH
-#define QUERY_DIGEST_MAX_LENGTH  65000
-#endif /* QUERY_DIGEST_MAX_LENGTH */
-
 typedef struct
 {
 	char*       s;
diff --git a/include/proxysql_structs.h b/include/proxysql_structs.h
index 5e82cd6..726fe22 100644
--- a/include/proxysql_structs.h
+++ b/include/proxysql_structs.h
@@ -735,6 +735,8 @@ __thread bool mysql_thread___enforce_autocommit_on_reads;
 __thread bool mysql_thread___servers_stats;
 __thread bool mysql_thread___commands_stats;
 __thread bool mysql_thread___query_digests;
+__thread int mysql_thread___query_digests_max_digest_length;
+__thread int mysql_thread___query_digests_max_query_length;
 __thread bool mysql_thread___default_reconnect;
 __thread bool mysql_thread___sessions_sort;
 
@@ -815,6 +817,8 @@ extern __thread bool mysql_thread___enforce_autocommit_on_reads;
 extern __thread bool mysql_thread___servers_stats;
 extern __thread bool mysql_thread___commands_stats;
 extern __thread bool mysql_thread___query_digests;
+extern __thread int mysql_thread___query_digests_max_digest_length;
+extern __thread int mysql_thread___query_digests_max_query_length;
 extern __thread bool mysql_thread___default_reconnect;
 extern __thread bool mysql_thread___sessions_sort;
 
diff --git a/lib/MySQL_Thread.cpp b/lib/MySQL_Thread.cpp
index a81b21b..9130153 100644
--- a/lib/MySQL_Thread.cpp
+++ b/lib/MySQL_Thread.cpp
@@ -190,6 +190,8 @@ static char * mysql_thread_variables_names[]= {
 	(char *)"enforce_autocommit_on_reads",
 	(char *)"threshold_query_length",
 	(char *)"threshold_resultset_size",
+	(char *)"query_digests_max_digest_length",
+	(char *)"query_digests_max_query_length",
 	(char *)"wait_timeout",
 	(char *)"max_connections",
 	(char *)"default_max_latency_ms",
@@ -268,6 +270,8 @@ MySQL_Threads_Handler::MySQL_Threads_Handler() {
 	variables.max_transaction_time=4*3600*1000;
 	variables.threshold_query_length=512*1024;
 	variables.threshold_resultset_size=4*1024*1024;
+	variables.query_digests_max_digest_length=2*1024;
+	variables.query_digests_max_query_length=65000; // legacy default
 	variables.wait_timeout=8*3600*1000;
 	variables.max_connections=10*1000;
 	variables.default_max_latency_ms=1*1000; // by default, the maximum allowed latency for a host is 1000ms
@@ -476,6 +480,8 @@ int MySQL_Threads_Handler::get_variable_int(char *name) {
 	if (!strcasecmp(name,"max_transaction_time")) return (int)variables.max_transaction_time;
 	if (!strcasecmp(name,"threshold_query_length")) return (int)variables.threshold_query_length;
 	if (!strcasecmp(name,"threshold_resultset_size")) return (int)variables.threshold_resultset_size;
+	if (!strcasecmp(name,"query_digests_max_digest_length")) return (int)variables.query_digests_max_digest_length;
+	if (!strcasecmp(name,"query_digests_max_query_length")) return (int)variables.query_digests_max_query_length;
 	if (!strcasecmp(name,"wait_timeout")) return (int)variables.wait_timeout;
 	if (!strcasecmp(name,"max_connections")) return (int)variables.max_connections;
 	if (!strcasecmp(name,"default_query_delay")) return (int)variables.default_query_delay;
@@ -680,6 +686,14 @@ char * MySQL_Threads_Handler::get_variable(char *name) {	// this is the public f
 		sprintf(intbuf,"%d",variables.threshold_resultset_size);
 		return strdup(intbuf);
 	}
+	if (!strcasecmp(name,"query_digests_max_digest_length")) {
+		sprintf(intbuf,"%d",variables.query_digests_max_digest_length);
+		return strdup(intbuf);
+	}
+	if (!strcasecmp(name,"query_digests_max_query_length")) {
+		sprintf(intbuf,"%d",variables.query_digests_max_query_length);
+		return strdup(intbuf);
+	}
 	if (!strcasecmp(name,"wait_timeout")) {
 		sprintf(intbuf,"%d",variables.wait_timeout);
 		return strdup(intbuf);
@@ -981,6 +995,24 @@ bool MySQL_Threads_Handler::set_variable(char *name, char *value) {	// this is t
 			return false;
 		}
 	}
+	if (!strcasecmp(name,"query_digests_max_digest_length")) {
+		int intv=atoi(value);
+		if (intv >= 16 && intv <= 1*1024*1024) {
+			variables.query_digests_max_digest_length=intv;
+			return true;
+		} else {
+			return false;
+		}
+	}
+	if (!strcasecmp(name,"query_digests_max_query_length")) {
+		int intv=atoi(value);
+		if (intv >= 16 && intv <= 16*1024*1024) {
+			variables.query_digests_max_query_length=intv;
+			return true;
+		} else {
+			return false;
+		}
+	}
 	if (!strcasecmp(name,"wait_timeout")) {
 		int intv=atoi(value);
 		if (intv >= 0 && intv <= 20*24*3600*1000) {
@@ -2056,6 +2088,8 @@ void MySQL_Thread::refresh_variables() {
 	mysql_thread___max_transaction_time=GloMTH->get_variable_int((char *)"max_transaction_time");
 	mysql_thread___threshold_query_length=GloMTH->get_variable_int((char *)"threshold_query_length");
 	mysql_thread___threshold_resultset_size=GloMTH->get_variable_int((char *)"threshold_resultset_size");
+	mysql_thread___query_digests_max_digest_length=GloMTH->get_variable_int((char *)"query_digests_max_digest_length");
+	mysql_thread___query_digests_max_query_length=GloMTH->get_variable_int((char *)"query_digests_max_query_length");
 	mysql_thread___wait_timeout=GloMTH->get_variable_int((char *)"wait_timeout");
 	mysql_thread___max_connections=GloMTH->get_variable_int((char *)"max_connections");
 	mysql_thread___default_query_delay=GloMTH->get_variable_int((char *)"default_query_delay");
diff --git a/lib/Query_Processor.cpp b/lib/Query_Processor.cpp
index 19b4715..76ba7c7 100644
--- a/lib/Query_Processor.cpp
+++ b/lib/Query_Processor.cpp
@@ -110,7 +110,7 @@ class QP_query_digest_stats {
 	int hid;
 	QP_query_digest_stats(char *u, char *s, uint64_t d, char *dt, int h) {
 		digest=d;
-		digest_text=strdup(dt);
+		digest_text=strndup(dt, mysql_thread___query_digests_max_digest_length);
 		username=strdup(u);
 		schemaname=strdup(s);
 		count_star=0;
@@ -901,7 +901,9 @@ void Query_Processor::query_parser_init(SQP_par_t *qp, char *query, int query_le
 	//qp->first_comment[0]=0; // initialize it to 0 . Useful to determine if there is any string or not
 	if (mysql_thread___query_digests) {
 		qp->digest_text=mysql_query_digest_and_first_comment(query, query_length, &qp->first_comment);
-		qp->digest=SpookyHash::Hash64(qp->digest_text,strlen(qp->digest_text),0);
+		// the hash is computed only up to query_digests_max_digest_length bytes
+		int digest_text_length=strnlen(qp->digest_text, mysql_thread___query_digests_max_digest_length);
+		qp->digest=SpookyHash::Hash64(qp->digest_text, digest_text_length, 0);
 #ifdef DEBUG
 		if (qp->first_comment && strlen(qp->first_comment)) {
 			proxy_debug(PROXY_DEBUG_MYSQL_QUERY_PROCESSOR, 5, "Comment in query = %s \n", qp->first_comment);
diff --git a/lib/c_tokenizer.c b/lib/c_tokenizer.c
index c3f0551..209f560 100644
--- a/lib/c_tokenizer.c
+++ b/lib/c_tokenizer.c
@@ -6,6 +6,9 @@
 
 #include "c_tokenizer.h"
 
+
+extern __thread int mysql_thread___query_digests_max_query_length;
+
 tokenizer_t tokenizer( const char* s, const char* delimiters, int empties )
 {
 
@@ -168,8 +171,8 @@ char *mysql_query_digest_and_first_comment(char *s, int _len, char **first_comme
 	int cmd=0;
 
 	int len = _len;
-	if (_len > QUERY_DIGEST_MAX_LENGTH) {
-		len = QUERY_DIGEST_MAX_LENGTH;
+	if (_len > mysql_thread___query_digests_max_query_length) {
+		len = mysql_thread___query_digests_max_query_length;
 	}
 	char *r = (char *) malloc(len + SIZECHAR);
 
